## Apriori 实现总结 ##

1. 算法实现难点总结  
Apriori的算法不算复杂。  
首先找到1-频繁项集 L1，然后L1 * L1 再结合支持度 生成2-频繁项集。以此类推一直到项集为空  
但是在算法的实现上就比较麻烦了。  
	1. 在原始的交易记录上，生成有效的2-频繁项集以及2以上的频繁项集。   
		我的解决方案是 L1 * L1 然后判断当前的频繁项集-candidate 在当前的交易记录上是不是都有   
	2. 最麻烦的还是生成关联规则  
		感觉代码又多了一倍
2. 其他：  
	1.  在生成关联规则的时候，有一个之前知道但不记得的地方：   
	比如{1, 5} -> {2} 跟 {2 , 5} -> {1} 都可以生成 {5} -> {1, 2}  
	如果两边都生成的话，计算复杂度以及时间消耗说不定要多一倍  
	解决方案在《数据挖掘导论》上面说过，即只把大于Y-X的项才能挪到右边， 也就是说 只有 {2, 5} -> {1} 才能生成 {5} -> {1, 2}  
	2. 第一次使用了很多Arrays下面的方法，比如:
		* sort 排序  
		* binarySearch 二分查找  
		* copyOf 数组复制  
		* toString 字符串化  
3. 感觉自己做得还不够好的地方：  
	1. 在判断2及以上的频繁项集在某个交易记录是否存在的时候，方法很笨，对于itemset 逐个遍历然后对当前的项二分查找。 实际上因为两边都是有序数列，可以更快速一些  
	参考代码里面的频繁项集是一个treeSet，因此使用了containsAll来进行判断。 根据[StackOverflow](http://stackoverflow.com/questions/10199772/what-is-the-cost-of-containsall-in-java) jdk自己的做法也是这样，遍历 + 搜索
	2. 在存储频繁项集的支持度的时候，使用的是最简单的数据结构Map. 因为这个map无法对String[]类型的数据进行正确的判断（原因应该是String[]的equals是对地址进行判断而不是值）所以需要做一次转换，即将String[] 通过一些特殊字符（比如：$$）连起来变成一个单个的字符串。在取出使用的时候，又进行切分，感觉效率低下，使用不便
	Sample.Apriori里面使用了面向对象的做法，支持度本身就是频繁项集的一个属性，这样做自然就解决了这个问题。  
	3. 完全面向过程，完全没有面向对象
	4. 目前的支持度只支持绝对数值，还不能支持百分比形式的支持度